{
  "id": "sorting_music",
  "label": "sorting_music",
  "metadata": {
    "top": -400,
    "right": 400,
    "bottom": 400,
    "left": -400,
    "wrap": [
      false,
      false
    ],
    "bounce": true,
    "bgcolor": 102,
    "roundsCanLoop": true,
    "showWebCam": false,
    "scaleX": 1,
    "scaleY": 1,
    "translateX": 0,
    "translateY": 0,
    "rotate": 0,
    "mirrorX": false,
    "mirrorY": false
  },
  "rounds": [],
  "blueprints": [
    {
      "name": "global",
      "scriptText": `# BLUEPRINT global
# TAG IsCharControllable false
# TAG IsPozyxControllable false
# TAG IsPtrackControllable false

// COMMENT KEY
// ðŸ”Ž WHAT DOES THIS DO? heading
// ðŸ”Ž body
// âœï¸ LETS CHANGE THIS: heading
// âœï¸ body

# PROGRAM INIT

// ðŸ”Ž WHAT DOES THIS MODEL DO?
// ðŸ”Ž This starter model is inteded to help users explore how people interacting with each other
// ðŸ”Ž might impact the other people. The existing code mirrors a basic disease spread scenario for
// ðŸ”Ž some sample code to muck with
// ðŸ”Ž Change this description once you are ready to share the model so others know how it is supposed to work.

prop global.visible setTo false
addFeature Population
addFeature IU
addFeature Graphing
addProp song_name string ''
addProp stack_counter number 0
addProp num_players number 0
addProp countReady number 0
addProp test_sorting boolean false
addProp count_num_comparisons number 0
// required directive
# PROGRAM UPDATE
// onEvent Start [[
// prop global.song_name setTo 'title1'
// propPush global.song_name
// prop global.stack_counter add 1
// prop global.song_name setTo 'title2'
// propPush global.song_name
// prop global.stack_counter add 1
// prop global.song_name setTo 'title3'
// propPush global.song_name
// prop global.stack_counter add 1
// dbgStack


// featCall global.Population charactersForEach song [[
// ifExpr {{ global.getProp('stack_counter').value > 0 }} [[
// propPop song.role
// dbgStack
// prop global.stack_counter sub 1
// ]]
// prop song.role setTo 'test'
// ]]
// ]]

ifExpr {{ global.getProp('countReady').value == global.getProp('num_players').value }} [[
  prop global.test_sorting setTo true
]]

ifExpr {{ global.getProp('countReady').value != global.getProp('num_players').value }} [[
  prop global.test_sorting setTo false
]]
`
    },
    {
      "name": "Background",
      "scriptText": `# BLUEPRINT Background
# TAG isCharControllable false
# TAG isPozyxControllable false
# TAG isPTrackControllable false

# PROGRAM INIT
addFeature Costume
featProp Background.Costume.costumeName setTo 'SM_background.png'
featProp Background.Costume.scale setTo 0.82

# PROGRAM UPDATE
// code to run every frame
// when xxx touches yyy [[ ]]
// every 5 runAfter [[ ]]
// onEvent Tick [[ ]]

// COMMENT KEY
// ðŸ”Ž WHAT DOES THIS DO? heading
// ðŸ”Ž body
// âœï¸ LETS CHANGE THIS: heading
// âœï¸ body`
    },
    {
      "name": "song",
      "scriptText": `# BLUEPRINT song
# TAG isPozyxControllable true
# TAG isCharControllable true
# TAG isPTrackControllable false

// COMMENT KEY
// ðŸ”Ž WHAT DOES THIS DO? heading
// ðŸ”Ž body
// âœï¸ LETS CHANGE THIS: heading
// âœï¸ body


# PROGRAM INIT
// add the features we are likely to use
addFeature Costume
addFeature Population

// set the costume
featProp song.Costume.costumeName setTo 'SM_APT.png'
featProp song.Costume.scale setTo 0.4

// add other features
addFeature Graphing
addFeature Physics
addFeature Touches

// make sure we track interactions with the NPC
featCall song.Touches monitor 'song' b2b
featCall song.Touches monitor 'rankChart' b2b

// add any properties specific to the PC

// âœï¸ Intended to capture the song name. Each agent is going to have a different song_name and accordingly a different sort_by value and a different costume
addProp song_name string 'song_name'
// âœï¸ a number that indicate the rank of the songs ( can change based on year, number of listening etc. If alphabetically please use the relevant number that is in reference to the first letter (1=a, z=26)
addProp sort_by_value number 2
// âœï¸ A variable to save the value to sort by of the other song temporarly
addProp value_to_compare number -100
// âœï¸ saves a temp value of the song name I am comparing with
addProp compare_to_song_name string
// âœï¸ check_order is set to true if the player is interacting with the ranking_chart
addProp check_order boolean false
// âœï¸ Checking that we are comparing with maximum 1 agent at a time
addProp has_partner number 0
// âœï¸ boolean used to ensure song arent counted as more than one player on init
addProp player boolean false
// âœï¸ saves for the record what kind of attribute are we sorting by
addProp sort_by_attribute string


// display the meter if relevant
// featCall agent.Graphing bindMeterTo energy

# PROGRAM UPDATE
onEvent ROUNDINIT [[
  ifProp song.player equal false [[
    prop global.num_players add 1
    dbgOut {{ 'num of active players: ' + global.getProp('num_players').value }}
    prop song.player setTo true

  ]]
]]

when song touches song [[
  ifProp song.has_partner equal 0 [[
    // push the song_name property of the other agent and put it into a temporary property on the song
    propPush character.song_name
    propPop song.compare_to_song_name
    propPush song.song_name
    propPop character.compare_to_song_name
    // compare a temporary property with the song_name property of the other song I am comparing with to check if the other agent is myself
    ifExpr {{ song.getProp('song_name').value != song.getProp('compare_to_song_name').value }} [[
      // if the other agent is not me, check if the other agent has a partner and if it is carrying finch properties.
      ifProp character.has_partner equal 0 [[
        // set the song and agent as having a partner
        prop song.has_partner setTo 1
        prop character.has_partner setTo 1
        // push the sort by value property of the agent and put it in a temporary beak length property of the song and vise versa
        propPush character.sort_by_value
        dbgStack
        propPop song.value_to_compare
        dbgOut {{ 'added a value to compare to song: ' + song.getProp('song_name').value + ' and set the following value: ' + song.getProp('value_to_compare').value }}
        propPush song.sort_by_value
        dbgStack
        propPop character.value_to_compare
        dbgOut {{ 'added a value to compare to song: ' + character.getProp('song_name').value + ' and set the following value: ' + character.getProp('value_to_compare').value }}
        // making sure value to compare updates correctly
        ifExpr {{ song.getProp('value_to_compare').value != -100 && character.getProp('value_to_compare').value != -100 }} [[
          // compare the sort by value and temporary (compared to) sort by value properties of the song. If song is larger, change the song costume to larger and the agent costume to smaller
          ifExpr {{ song.getProp('sort_by_value').value > song.getProp('value_to_compare').value }} [[
            featProp song.Costume.scale setTo 0.55
            featProp character.Costume.scale setTo 0.25
            featProp song.Costume.glow setTo 1
            featProp character.Costume.glow setTo 1
            // Count and log the number of comparisons between songs
            prop global.count_num_comparisons add 1
            dbgOut {{ 'num of comparisons so far: ' + global.getProp('count_num_comparisons').value }}
            dbgOut {{ 'Comaprison event between ' + song.getProp('song_name').value + ' and ' + character.getProp('song_name').valu + ' with results: ' + song.getProp('song_name').value + ' is bigger ' }}
          ]]
          ifExpr {{ song.getProp('sort_by_value').value < song.getProp('value_to_compare').value }} [[
            featProp song.Costume.scale setTo 0.25
            featProp character.Costume.scale setTo 0.55
            featProp song.Costume.glow setTo 1
            featProp character.Costume.glow setTo 1
            // Count and log the number of comparisons between songs
            prop global.count_num_comparisons add 1
            dbgOut {{ 'num of comparisons so far: ' + global.getProp('count_num_comparisons').value }}
            dbgOut {{ 'Comaprison event between ' + song.getProp('song_name').value + ' and ' + character.getProp('song_name').valu + ' with results: ' + song.getProp('song_name').value + ' is smaller ' }}

          ]]
          ifExpr {{ song.getProp('sort_by_value').value == song.getProp('value_to_compare').value }} [[
            featProp song.Costume.scale setTo 0.4
            featProp character.Costume.scale setTo 0.4
            featProp song.Costume.glow setTo 1
            featProp character.Costume.glow setTo 1
            // Count and log the number of comparisons between songs
            prop global.count_num_comparisons add 1
            dbgOut {{ 'num of comparisons so far: ' + global.getProp('count_num_comparisons').value }}
            dbgOut {{ 'Comaprison event between ' + song.getProp('song_name').value + ' and ' + character.getProp('song_name').valu + ' with results: equal ' }}
          ]]
        ]]
      ]]
    ]]
  ]]
]]

// change the costume of song after interacting with another song to compare sot by value properties
when song lasttouches song [[
  // resetting values for both songs
  prop song.has_partner setTo 0
  prop character.has_partner setTo 0
  featProp song.Costume.scale setTo 0.4
  featProp character.Costume.scale setTo 0.4
  prop song.value_to_compare setTo 0
  prop character.value_to_compare setTo -100
  prop song.compare_to_song_name setTo
  prop character.compare_to_song_name setTo
  dbgOut {{ 'end of comparison event between ' + song.getProp('song_name').value + ' and ' + character.getProp('song_name').value }}
]]

// when a song actively interacts with the rank chart, set the player status as ready to make a prediction and add one to the global property to count ready players
when song touches rankChart [[
  ifProp song.check_order equal false [[
    featProp song.Costume.glow setTo 1
    prop song.check_order setTo true
    prop global.countReady add 1
    dbgOut {{ 'song: ' + song.getProp('song_name').value + ' is on the rank chart with total songs ready to test sorting of: ' + global.getProp('countReady').value }}
  ]]
]]

// when song leave the rank chart, set the player status as not ready to make a prediction and remove their count from the global property to count ready players
when song lasttouches rankChart [[
  ifProp global.countReady greaterThan 0 [[
    prop global.countReady sub 1
  ]]
  prop song.check_order setTo false
  dbgOut {{ 'song: ' + song.getProp('song_name').value + ' just left the rank chart with total songs ready to test sorting of: ' + global.getProp('countReady').value }}
]]

// test sorting
ifProp global.test_sorting equal true [[
  dbgOut {{ 'test of sorting in progress' }}
  dbgOut {{ 'for song name: ' + song.getProp('song_name').value + ' Y value is: ' + song.getProp('y').value }}

]]

// This is stuff that happens constantly and you can also check certain conditions
// For example every 1 runAtStart will run every time this is called, including the first, whereas every 5 will happen less offten and not the first time

every 1 runAtStart [[

]]`
    },
    {
      "name": "rankChart",
      "scriptText": `# BLUEPRINT rankChart
# TAG isPozyxControllable false
# TAG isCharControllable false
# TAG isPTrackControllable false

// COMMENT KEY
// ðŸ”Ž WHAT DOES THIS DO? heading
// ðŸ”Ž body
// âœï¸ LETS CHANGE THIS: heading
// âœï¸ body

# PROGRAM INIT
// setup the NPC costume
addFeature Costume
featProp rankChart.Costume.costumeName setTo 'SM_ranking_chart.png'
featProp rankChart.Costume.scale setTo 0.75

// add other features
addFeature Graphing
addFeature Physics
addFeature Touches

featCall rankChart.Touches monitor 'song' b2b

// add any properties specific to the PC / NPC


# PROGRAM UPDATE
// This is stuff that happens constantly and you can also check certain conditions
// For example every 1 runAtStart will run every time this is called, including the first, whereas every 5 will happen less offten and not the first time
// This is also where you can handle touches between characters such as When Algae touches Fish`
    },
    {
      "name": "Timer",
      "scriptText": `# BLUEPRINT Timer
# TAG isCharControllable false
# TAG isPozyxControllable false
# TAG isPTrackControllable false

// ðŸ”Ž WHAT DOES THIS CHARACTER DO?
// ðŸ”Ž This is a timer character so that we can see how much time has passed in our model
// ðŸ”Ž We can use that time to think about how long the ecosystem survives if we want

# PROGRAM INIT
addFeature Graphing
addFeature Costume

// Hide the actual art since we just want the text to displaay
featProp Timer.Costume.costumeName setTo 'GEN_onexone.json'
featProp Timer.Costume.scale setTo 1

// A property to track the time
addProp time number 0

// set the initial label and then update it below during update
exprPush {{ 'Time: ' + Timer.getProp('time').value }}
featPropPop Timer.Graphing.text

# PROGRAM UPDATE
// Every second, add one to the time and then update the text on the timer character to say Time: #
// timer stops when the test_sorting phase begins
every 1 runAtStart [[
  ifProp global.test_sorting equal false [[
    prop Timer.time add 1
    exprPush {{ 'Time: ' + Timer.getProp('time').value }}
    featPropPop Timer.Graphing.text
  ]]
]]`
    },
    {
      "name": "graph_comparisons",
      "scriptText": `# BLUEPRINT graph_comparisons
# TAG isCharControllable false
# TAG isPozyxControllable false
# TAG isPTrackControllable false

# PROGRAM INIT
addFeature Costume
addFeature Graphing
addFeature Population

addProp total_comparisons_count number 0

featProp graph_comparisons.Costume.costumeName setTo 'GEN_onexone.json'
featProp graph_comparisons.Graphing.isLargeGraphic setTo true
featProp graph_comparisons.Graphing.graphProp setTo 'total_comparisons_count'
featProp graph_comparisons.Graphing.graphMinY setTo 0
featProp graph_comparisons.Graphing.graphMaxY setTo 50
featProp graph_comparisons.Graphing.graphMinX setTo 0
featProp graph_comparisons.Graphing.graphMaxX setTo 50
featProp graph_comparisons.Graphing.text setTo 'comaparisons count'
featProp graph_comparisons.Graphing.meterColor setTo 65280
featProp graph_comparisons.Graphing.wordWrapWidth setTo 150


// what row are we in on the screen (4 total, incremented at end of round)
addProp row number 1

addProp fieldType string ''

# PROGRAM UPDATE
ifExpr {{global.getProp('count_num_comparisons').value != graph_comparisons.getProp('total_comparisons_count').value}} [[
  ifProp graph_comparisons.row equal 1 [[
    propPush global.count_num_comparisons
    propPop graph_comparisons.total_comparisons_count
  ]]
]]`
    }
  ],
  "instances": [
    {
      "id": "0",
      "label": "Background0",
      "bpid": "Background",
      "initScript": `prop Background.x setTo 4.31
prop Background.y setTo 4.15`
    },
    {
      "id": "1",
      "label": "rankChart1",
      "bpid": "rankChart",
      "initScript": `prop rankChart.x setTo 325.62
prop rankChart.y setTo -4.36`
    },
    {
      "id": "2",
      "label": "song2",
      "bpid": "song",
      "initScript": `prop song.x setTo 54.22
prop song.y setTo -147.94
prop song.sort_by_value setTo 1
prop song.song_name setTo 'song2'
featProp song.Costume.costumeName setTo 'SM_thats_so_true.png'`
    },
    {
      "id": "3",
      "label": "song3",
      "bpid": "song",
      "initScript": `prop song.x setTo -232.9
prop song.y setTo -136.98
prop song.sort_by_value setTo 2
prop song.song_name setTo 'song3'`
    },
    {
      "id": "4",
      "label": "song4",
      "bpid": "song",
      "initScript": `prop song.x setTo -95.73
prop song.y setTo -41.12
prop song.sort_by_value setTo 3
prop song.song_name setTo 'song4'
featProp song.Costume.costumeName setTo 'SM_die_with_a_smile.png'`
    },
    {
      "id": "6",
      "label": "graph_comparisons6",
      "bpid": "graph_comparisons",
      "initScript": `prop graph_comparisons.x setTo -473.16
prop graph_comparisons.y setTo -266.19`
    },
    {
      "id": "7",
      "label": "Timer7",
      "bpid": "Timer",
      "initScript": `prop Timer.x setTo -454.54
prop Timer.y setTo -397.29`
    }
  ]
}